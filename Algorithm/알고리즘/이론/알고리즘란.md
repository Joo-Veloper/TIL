## 알고리즘 정의와 조건 </br>
주어진 문제를 해결하기 위한 단계적인 절차를 말한다. 컴퓨터에서 어떤 일을 하는 절차를 표현하기 위해 명령어들을 사용하는데, 결국 알고리즘은 특정한 일을 수행하는 명령어들의 집합으로 볼 수 있다.
![download](https://github.com/Onebye1/TIL/assets/134623719/b615ad2e-3cf9-4531-9981-3a219f1d53a1)</br>

#### 알고리즘의 조건

입력 : 알고리즘이 입력을 받는다면 모호하지 않고 잘 정의된 입력이어야 한다. 알고리즘은 0개 이상의 입력을 갖는다.</br>
출력 : 출력은 명확하게 정의되어야 하며 1개 아상의 출력이 반드시 존재하여야 한다.</br>
명확성 : 각 명령어의 의미는 모호하지 않고 명확해야 한다.</br>
유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안된다.</br>
유효성 : 명령어들은 현재 실행 가능한 연산이어야 한다. 미래에 개발될 기술 등을 포함해서는 안된다. </br>

#### 자연어 표현</br>
find_max(a)</br>
리스트 A의 첫 번째 항목을 변수 Max에 복사</br>
리스트 A의 다음 항목들을 차례대로 max와 비교하여, max보다 더 크면 그 값을 max로 복사</br>
배열 A의 모든 요소를 비교했으면 max를 반환</br>

#### 흐름도 표현</br>
일반적으로 흐름도를 사용하여 알고ㄹ즘의 과정과 결정 구조를 시각적으로 표현할 수 있습니다.
 
![스크린샷 2023-08-09 153402](https://github.com/Onebye1/TIL/assets/134623719/64921bf7-9417-4433-9c14-f267df43eb70)<br/>

1. 시작 : 프로그램 실행 시작<br/>
2. 두 수 입력 : 사용자로부터 두 개의 수를 입력받습니다.<br/>
3. 두 수 더하기 : 입력받은 두 수를 더합니다.<br/>
4. 결과 출력 : 더한 결과를 화면에 출력합니다.<br/>
5. 종료 : 프로그램 실행을 종료합니다.<br/>

#### 알고리즘 설계 기법 <br/>

억지 기법과 완전 탐색 : 문제의 정의를 가장 직접 사용하는 방법으로, 원하는 답을 구할 때까지 모든 가능한 경우를 테스트한다. 3장에서 이 기법을 다룬다.<br/>
축소 정복 : 주어진 문제를 하나의 좀 더 작은 문제로 축소하여 해결하는 방법<br/>
분할 정복 : 주어진 문제를 여러 개의 더 작은 문제로 반복적으로 분할하여 해결 가능한 충분히 작은 문제로 만든 다음 해결<br/>
동적 계획법 : 원래의 문제를 더 작은 문제로 나누는 면에서 분할정복과 유사하지만, 작은 문제를 먼저 해결하고 결과를 저장 하여 다음에 더 큰 문제를 해결 할 때 사용한다는 것이 분할정복과 가장 큰 차이<br/>
탐욕적 기법 : 단순하고 직관적인 방법으로 모든 경우를 고려해 보고 가장 좋은 답을 찾는 것이 아니라 어떤 결정을 해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택하는 방법 <br/>
백트래킹과 분기 한정 기법 : 상태공간트리에서 해를 단계적으로 ㅊ찾아가는 과정에서 현재의 해가 최종 해가 될 수 없다고 판단되면 더 이상 탐색하지 않고 되돌아가서 다른 후보해를 탐색하는 방법<br/>


#### 정렬(Sorting)

정렬(Sorting) 알고리즘은 주어진 데이터 집합을 특정한 기준에 따라 오름차순(또는 내림차순)으로 재배열하는 알고리즘입니다. 정렬은 컴퓨터 과학과 데이터 처리 분야에서 매우 중요한 작업으로, 데이터의 정리, 탐색, 필터링 등 다양한 작업을 수행하는 데에 활용됩니다.<br/>
1. 버블 정렬(Bubble Sort): 인접한 두 요소를 비교하면서 작은 값을 앞으로 이동시키는 방식으로 정렬합니다.<br/>
2. 선택 정렬(Selection Sort): 가장 작은 값을 선택하여 정렬된 부분과 교환하는 방식으로 배열을 정렬합니다.<br/>
3. 삽입 정렬(Insertion Sort): 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 값을 정렬된 부분에 삽입하는 방식으로 정렬합니다.<br/>
4. 퀵 정렬(Quick Sort): 분할 정복(Divide and Conquer) 기법을 사용하여 배열을 작은 요소와 큰 요소로 분할하고, 각 부분을 정렬합니다.<br/>
5. 병합 정렬(Merge Sort): 분할 정복 기법을 사용하여 배열을 반으로 나눈 후, 나눈 부분들을 병합하면서 정렬하는 방식으로 정렬합니다.<br/>
6. 힙 정렬(Heap Sort): 이진 힙(Binary Heap) 자료구조를 사용하여 요소를 정렬하는 방식으로, 힙을 구성하고 요소를 추출하여 정렬합니다.<br/>


#### 그래프
알고리즘에서 그래프는 다양한 요소들 간의관계를 나타내는 추상적인 자료구조입니다. 그래프는 노드와 노드들을 연결하는 간선으로 구성됩니다. <br/>
그래프는 네트워크, 지도, 소셜 미디어 관계, 저기 회로 등 다양한 분야에서 사용됩니다. <br/>

1. 무방향 그래프<br/>
간선에 방향성이 없는 그래프로, 노드 사이의 연결 관계가 양방향입니다<br/>
2. 방향 그래프<br/>
간선에 방향성이 있는 그래프로, 한 노드에서 다른 노드로의 화살표 방향이 존재합니다.<br/>

#### 알고리즘 작업 수행
1. 탐색 : 그래프 내에서 노드나 간선을 순회하면서 원하는 정보를 찾는 작업입니다.<br/>
대표적으로 DFS와 BFS가 있습니다.<br/>
2. 최단 경로 문제 : 두 노드 사이의 최단 경로를 찾는 작업으로, 다익스트라 알고리즘이나 벨만-포드 알고리즘 등을 사용합니다. <br/>
3. 신장 트리 문제 : 그래프 내에서 모든 노드를 포함하면서 사이클이 없는 부분 그래프인 신장 트리를 찾는 작업으로, 프림 알고리즘이나 크루스칼 알고리즘이 사용됩니다. <br/>
4. 최소 비용 유량 문제 : 그래프의 간선에 용량과 비용이 있는 경우, 최소의 비용으로 특정 양의 유량을 보내는 문제입니다.<br/>
5. 위상 정렬 : 방향 그래프에서 노드들을 순서대로 나열하는 작업으로, 작업 순서나 의존 관계 등을 나타낼 때 사용됩니다.
